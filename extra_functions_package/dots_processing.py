"""
This script provides functions for processing and filtering singularity dots in 3D optical fields.

The primary purpose of the script is to identify clusters of singularity dots and apply various filtering algorithms to
 simplify their spatial structure. These singularities often appear in complex optical fields such as those generated by
  Laguerre-Gaussian beams. The filtering techniques implemented here allow for the reduction of noise and isolation of
   relevant clusters, aiding in the analysis and visualization of these singularities.

## Main Features

1. **Cluster Identification and Filtering**: The script provides several functions to identify and filter clusters of
 singularity dots based on their neighborhood configuration. Filters include identifying dots with zero, one, two,
  three, or specific planar neighbors.

2. **Customizable Filtering Process**: The script includes a global filtering function that applies all the filters
sequentially to simplify the dot dictionary.

3. **Interactive Visualization**: The script allows for saving and visualizing the singularity dots, which is helpful
 for understanding the spatial distribution of singularities.

## Key Functions

### filter_PlaneTwoClusters
Identifies and filters out two-dot horizontal clusters in three planes (x, y, z) from a given dictionary of dots.
This helps to simplify the field by averaging the positions of clustered singularities.

### filter_PlaneTwoClusters_Vertical
Placeholder function for future development to handle vertical clusters specifically.

### globalFilterDots
Applies all the available filtering functions to the input dictionary of dots. It helps in reducing the complexity of
 the dot field by filtering out unwanted clusters and isolated dots.

### filtered_dots
Wrapper function for `globalFilterDots` that combines all filtered dots into a single array, making it easier to
analyze the final, filtered set of singularities.

## Usage Example
The script is intended to be used as a part of a larger analysis pipeline for optical field singularities.
Users can call `globalFilterDots` to apply all filters and then use the `filtered_dots` function to obtain the processed
output.
Example shows the 3D plot of the trefoil knot.
"""

import extra_functions_package.functions_general as fg
import extra_functions_package.singularities as sing
import extra_functions_package.plotings as pl
import extra_functions_package.beams_and_pulses as bp
import numpy as np
import pickle


def buildSaveTrefoil():
	"""
	Generates a trefoil knot beam using Laguerre-Gaussian modes and saves the resulting singularity dots.

	This function creates a 3D mesh and generates a combination of Laguerre-Gaussian beams to form a trefoil knot.
	The singularity dots are then calculated and saved to files.

	Saves:
		- dots_dict.pkl: A dictionary containing the detected singularity dots.
		- dots.npy: A numpy array of the singularity dots.
	"""
	xyzMesh = fg.create_mesh_XYZ(2.1, 2.1, 0.7, 40, 40, 40, zMin=None)
	beam = bp.LG_combination(*xyzMesh,
	                         coefficients=[1.71, -5.66, 6.38, -2.30, -4.36],
	                         modes=[(0, 0), (0, 1), (0, 2), (0, 3), (3, 0)],
	                         width=[1, 1, 1, 1, 1])
	dotsDict, dotsInitial = sing.get_singularities(np.angle(beam), axesAll=True, returnDict=True)
	with open("dots_dict.pkl", 'wb') as f:
		pickle.dump(dotsDict, f)
	with open('dots.npy', 'wb') as f:
		np.save(f, dotsInitial)


def loadDots():
	"""
	Loads previously saved singularity dots from files.

	Returns:
		tuple: A tuple containing the numpy array of dots and the dictionary of singularity dots.
	"""
	with open("dots_dict.pkl", 'rb') as f:
		dots_dict = pickle.load(f)
	with open('dots.npy', 'rb') as f:
		dots = np.load(f)
	return dots, dots_dict


def plotDots(dots, dots_bound=None, show=True, color='black', size=15, width=185, fig=None,
             save=None):
	"""
	Plots the array of singularity dots in an interactive 3D plot.

	This function allows visualization of singularity dots in a web browser using Plotly. It supports both numpy
	arrays and dictionaries of dots, and provides options for customizing the appearance of the plot.

	Parameters:
		dots (array or dict): Array or dictionary of singularity dots to plot.
		dots_bound (array or dict, optional): Dots used to set the bounding box frames. Defaults to `dots` itself.
		show (bool): Whether to display the plot in the browser. Defaults to True.
		color (str): Color of the dots. Defaults to 'black'.
		size (int): Size of the dots. Defaults to 15.
		width (int): Width of the shell of the dots for visualization. Defaults to 185.
		fig (Figure, optional): Existing figure to add plots to. Defaults to None.
		save (str, optional): Path to save the plot as an HTML file. Defaults to None.

	Returns:
		Figure: The Plotly figure containing the plotted dots.
	"""
	colorLine = 'white'
	if isinstance(dots, dict):
		dots = np.array([dot for dot in dots])
	if isinstance(dots_bound, dict):
		dots_bound = np.array([dot for dot in dots_bound])
	if dots_bound is None:
		dots_bound = dots
	if fig is None:
		fig = pl.plot_3D_dots_go(dots, marker={'size': size, 'color': color,
		                                       'line': dict(width=width, color=colorLine)})
	else:
		pl.plot_3D_dots_go(dots, fig=fig, marker={'size': size, 'color': color,
		                                          'line': dict(width=width, color=colorLine)})
	pl.box_set_go(fig, mesh=None, autoDots=dots_bound, perBox=0.01)
	if save is not None:
		fig.write_html(save)
	if show:
		fig.show()
	return fig


def plotDots_Hopf(dots, dots_bound=None, show=True, color='black', size=15, width=185, fig=None,
                  save=None, lines=True, **kwargs):
	"""
	Plots the array of singularity dots with options specific for Hopf link visualizations.

	This function extends the `plotDots` function by adding options for visualizing the Hopf link structure,
	including the ability to draw bounding box frames with lines and additional customization options.

	Parameters:
		dots (array or dict): Array or dictionary of singularity dots to plot.
		dots_bound (array or dict, optional): Dots used to set the bounding box frames. Defaults to `dots` itself.
		show (bool): Whether to display the plot in the browser. Defaults to True.
		color (str): Color of the dots. Defaults to 'black'.
		size (int): Size of the dots. Defaults to 15.
		width (int): Width of the shell of the dots for visualization. Defaults to 185.
		fig (Figure, optional): Existing figure to add plots to. Defaults to None.
		save (str, optional): Path to save the plot as an HTML file. Defaults to None.
		lines (bool): Whether to include lines in the bounding box frames. Defaults to True.
		**kwargs: Additional keyword arguments for further customization.

	Returns:
		Figure: The Plotly figure containing the plotted dots.
	"""
	colorLine = 'black'
	if isinstance(dots, dict):
		dots = np.array([dot for dot in dots])
	if isinstance(dots_bound, dict):
		dots_bound = np.array([dot for dot in dots_bound])
	if dots_bound is None:
		dots_bound = dots
	if fig is None:
		fig = pl.plot_3D_dots_go(dots, marker={'size': size, 'color': color,
		                                       'line': dict(width=width, color=colorLine)}, **kwargs)
	else:
		pl.plot_3D_dots_go(dots, fig=fig, marker={'size': size, 'color': color,
		                                          'line': dict(width=width, color=colorLine)}, **kwargs)
	pl.box_set_go(fig, mesh=None, autoDots=dots_bound, perBox=0.01, lines=lines)
	if save is not None:
		fig.write_html(save)
	if show:
		fig.show()
	return fig


def neighboursDots(x_c, y_c, z_c, dots_dict):
	"""
	Finds all dots in a 3x3x3 neighborhood cube around a given dot and returns their count and coordinates.

	Parameters:
		x_c (int): X-coordinate of the central dot.
		y_c (int): Y-coordinate of the central dot.
		z_c (int): Z-coordinate of the central dot.
		dots_dict (dict): Dictionary containing all the dots.

	Returns:
		tuple: A tuple containing the count of neighboring dots and a list of their coordinates.
	"""
	count = 0
	dots = []
	for x in [x_c - 1, x_c, x_c + 1]:
		for y in [y_c - 1, y_c, y_c + 1]:
			for z in [z_c - 1, z_c, z_c + 1]:
				if (x, y, z) in dots_dict:
					count += 1
					dots.append((x, y, z))
	return count, dots


def filter_ZeroNeighbours(dots_dict):
	"""
	Filters out dots with no neighbors from the dictionary of dots.

	This function finds all dots with only one neighbor, which indicates that they are isolated. These dots
	are removed from the dictionary to simplify the dot structure.

	Parameters:
		dots_dict (dict): Dictionary containing all the dots.

	Returns:
		tuple: A tuple containing an array of the new dots and an array of problematic dots that were removed.
	"""
	new_dots = []
	dots_problem = []
	for dot in dots_dict:
		count, _ = neighboursDots(*dot, dots_dict)
		if count == 1:
			dots_problem.append(dot)
	for dot in dots_problem:
		dots_dict.pop(dot)
	return np.array(new_dots), np.array(dots_problem)


def filter_OneNeighbours(dots_dict):
	"""
	Filters out dots with only one neighbor from the dictionary of dots.

	This function finds all dots that have exactly two neighbors and removes them from the dictionary.
	These dots are often not part of a cluster and can be filtered out to simplify the structure.

	Parameters:
		dots_dict (dict): Dictionary containing all the dots.

	Returns:
		tuple: A tuple containing an array of the new dots and an array of problematic dots that were removed.
	"""
	new_dots = []
	dots_problem = []
	for dot in dots_dict:
		count, _ = neighboursDots(*dot, dots_dict)
		if count == 2:
			dots_problem.append(dot)
	for dot in dots_problem:
		dots_dict.pop(dot)
	return np.array(new_dots), np.array(dots_problem)


def filter_TwoNeighbours(dots_dict):
	"""
	Filters out dots with only two neighbors based on trajectory sharpness.

	This function finds dots with exactly three neighbors and checks if the trajectory formed by these neighbors
	is sharp. If the trajectory is smooth, the dot is removed from the dictionary. Otherwise, it is kept.

	Parameters:
		dots_dict (dict): Dictionary containing all the dots.

	Returns:
		tuple: A tuple containing an array of new dots and an array of problematic dots that were removed.
	"""
	new_dots = []
	dots_problem = []
	dots_to_remove = []
	for dot in dots_dict:
		count, dots = neighboursDots(*dot, dots_dict)
		if count == 3:
			check = np.sum(dots, axis=0) / 3 - dot
			if np.sum(np.abs(check)) > 1:
				dots_problem.append(dot)
			else:
				dots_to_remove.append(dot)
				new_dots.append(dot)
	for dot in dots_problem:
		dots_dict.pop(dot)
	for dot in dots_to_remove:
		dots_dict.pop(dot)
	return np.array(new_dots), np.array(dots_problem)


def filter_ThreeNeighbours(dots_dict):
	"""
	Filters out dots with only three neighbors based on trajectory sharpness.

	This function finds all dots that have exactly four neighbors. The filtered dots are removed from the
	dictionary if they meet certain conditions regarding their neighboring relationships.

	Parameters:
		dots_dict (dict): Dictionary containing all the dots.

	Returns:
		tuple: A tuple containing an array of new dots and an array of problematic dots that were removed.
	"""
	new_dots = [(0, 0, 0)]
	dots_problem = []
	for dot in dots_dict:
		count, dots = neighboursDots(*dot, dots_dict)
		if count == 4:
			new_dots.append(dot)
	
	new_dots_pairs = set()
	new_dots_pairs_temp = set()
	dots_to_remove = []
	for dot in new_dots:
		count, dots = neighboursDots(*dot, new_dots)
		if count == 2:
			count_dot2, dots3 = neighboursDots(*(dots[dots.index(dot) - 1]), new_dots)
			if count_dot2 == 2:
				new_dots_pairs.add(tuple(np.sum(dots, axis=0) / 2))
				dots_to_remove.append(dot)
			elif count_dot2 == 3:
				new_dots_pairs_temp.add(tuple(np.sum(dots3, axis=0) / 3))
				for dot_ in dots3:
					dots_to_remove.append(dot_)
	new_dots = []
	for dot in dots_to_remove:
		try:
			dots_dict.pop(dot)
		except KeyError:
			pass
	for dot in set.union(new_dots_pairs, new_dots_pairs_temp):
		new_dots.append(dot)
	return np.array(list(new_dots)), np.array(dots_problem)


def filter_PlaneThreeClusters(dots_dict):
	"""
	Finds clusters of three dots in a plane and returns an average dot.

	This function searches for clusters of three dots in different planes (x, y, z). If such a cluster is found
	and the surrounding plane is clear, it calculates and returns an average dot to replace the cluster.

	Parameters:
		dots_dict (dict): Dictionary containing all the dots.

	Returns:
		tuple: A tuple containing an array of new dots and an array of problematic dots that were removed.
	"""
	
	def neighbours_InPlaneFourDots(x_c, y_c, z_c, dots_dict, direction):
		"""
		Finds all dots in a 2x2 plane around a given dot and returns their count and coordinates.

		Parameters:
			x_c (int): X-coordinate of the central dot.
			y_c (int): Y-coordinate of the central dot.
			z_c (int): Z-coordinate of the central dot.
			dots_dict (dict): Dictionary containing all the dots.
			direction (str): The direction of the plane ('x', 'y', or 'z').

		Returns:
			tuple: A tuple containing the count of neighboring dots and a list of their coordinates.
		"""
		count = 0
		dots = []
		if direction == 'z':
			for x_ in [x_c, x_c + 1]:
				for y_ in [y_c, y_c + 1]:
					if (x_, y_, z_c) in dots_dict:
						count += 1
						dots.append((x_, y_, z_c))
		elif direction == 'y':
			for x_ in [x_c, x_c + 1]:
				for z_ in [z_c, z_c + 1]:
					if (x_, y_c, z_) in dots_dict:
						count += 1
						dots.append((x_, y_c, z_))
		elif direction == 'x':
			for z_ in [z_c, z_c + 1]:
				for y_ in [y_c, y_c + 1]:
					if (x_c, y_, z_) in dots_dict:
						count += 1
						dots.append((x_c, y_, z_))
		return count, dots
	
	def planeEmptyCheck_helper(x_c, y_c, z_c, dots_dict, direction):
		"""
		Checks if a 4x4 plane around a given 2x2 dot area is clear of other dots.

		Parameters:
			x_c (int): X-coordinate of the central dot.
			y_c (int): Y-coordinate of the central dot.
			z_c (int): Z-coordinate of the central dot.
			dots_dict (dict): Dictionary containing all the dots.
			direction (str): The direction of the plane ('x', 'y', or 'z').

		Returns:
			bool: True if the surrounding plane is clear, False otherwise.
		"""
		
		def boundary_square_44(a, b):
			return [(a - 1, b - 1), (a - 1, b), (a - 1, b + 1), (a - 1, b + 2),
			        (a, b + 2), (a + 1, b + 2), (a + 2, b + 2),
			        (a + 2, b + 1), (a + 2, b), (a + 2, b - 1),
			        (a + 1, b - 1), (a, b - 1)]
		
		if direction == 'z':
			for x_, y_ in boundary_square_44(x_c, y_c):
				if (x_, y_, z_c) in dots_dict:
					return False
		elif direction == 'y':
			for x_, z_ in boundary_square_44(x_c, z_c):
				if (x_, y_c, z_) in dots_dict:
					return False
		elif direction == 'x':
			for z_, y_ in boundary_square_44(z_c, y_c):
				if (x_c, y_, z_) in dots_dict:
					return False
		
		return True
	
	new_dots = []
	dots_problem = []
	dots_to_remove = []
	for dot in dots_dict:
		# z
		count, dots = neighbours_InPlaneFourDots(*dot, dots_dict, direction='z')
		if count == 3:
			if planeEmptyCheck_helper(*dot, dots_dict, direction='z'):
				new_dots.append(tuple(np.sum(dots, axis=0) / 3))
				for dot_ in dots:
					dots_to_remove.append(dot_)
		# y
		count, dots = neighbours_InPlaneFourDots(*dot, dots_dict, direction='y')
		if count == 3:
			if planeEmptyCheck_helper(*dot, dots_dict, direction='y'):
				new_dots.append(tuple(np.sum(dots, axis=0) / 3))
				for dot_ in dots:
					dots_to_remove.append(dot_)
		# x
		count, dots = neighbours_InPlaneFourDots(*dot, dots_dict, direction='x')
		if count == 3:
			if planeEmptyCheck_helper(*dot, dots_dict, direction='x'):
				new_dots.append(tuple(np.sum(dots, axis=0) / 3))
				for dot_ in dots:
					dots_to_remove.append(dot_)
	for dot in set(dots_to_remove):
		dots_dict.pop(dot)
	return np.array(new_dots), np.array(dots_problem)


def filter_PlaneTwoClusters(dots_dict):
	"""
	Algorithm finds all 2 horizontal cluster in 3 planes and return average dots.
	Verticals are included since they are horizontal in z-planes.
	0000
	0**0
	0000
	All the good dots are removed from dots_dict (using the shallow copy)
	:param dots_dict: dictionary with all the dots
	:return: an array of new dots (removed and not) [(1,2,3), (3,4,5)...]
	"""
	
	def neighbours_InPlaneTwoDots(x_c, y_c, z_c, dots_dict, direction):
		"""
		Algorithm finds all dots in 2x2 plane around the dot, return their count and the dots themselves
		00
		*0
		:param x_c: (X, y, z) - dot, which neighbours are explored
		:param y_c: (x, Y, z) - dot, which neighbours are explored
		:param z_c: (x, Y, z) - dot, which neighbours are explored
		:param dots_dict: dictionary with all the dots
		:return: number of dots in the square 3x3x3 with the array of dots in it
		"""
		count = 0
		dots = []
		if direction == 'x':
			for x_ in [x_c, x_c + 1]:
				if (x_, y_c, z_c) in dots_dict:
					count += 1
					dots.append((x_, y_c, z_c))
		elif direction == 'y':
			for y_ in [y_c, y_c + 1]:
				if (x_c, y_, z_c) in dots_dict:
					count += 1
					dots.append((x_c, y_, z_c))
		elif direction == 'z':
			for z_ in [z_c, z_c + 1]:
				if (x_c, y_c, z_) in dots_dict:
					count += 1
					dots.append((x_c, y_c, z_))
		return count, dots
	
	def planeEmptyCheck_helper_twoDots(x_c, y_c, z_c, dots_dict, direction):
		"""
		Algorithm checks if there are any neighbours in 3x4 plane around the dots 2x1
		0000
		0**0
		0000 - TRUE
		:param x_c: (X, y, z) - dot, which neighbours are explored
		:param y_c: (x, Y, z) - dot, which neighbours are explored
		:param z_c: (x, Y, z) - dot, which neighbours are explored
		:param dots_dict: dictionary with all the dots
		:return: True if the area is clear
		"""
		
		def boundary_square_34(a, b):
			return [(a - 1, b - 1), (a - 1, b), (a - 1, b + 1),
			        (a, b + 1), (a + 1, b + 1),
			        (a + 1, b), (a + 1, b - 1),
			        (a, b - 1)]
		
		if direction == 'x':
			for x_, y_ in boundary_square_34(x_c, y_c):
				if (x_, y_, z_c) in dots_dict:
					for x__, z__ in boundary_square_34(x_c, z_c):
						if (x__, y_c, z__) in dots_dict:
							return False
		elif direction == 'y':
			for y_, x_ in boundary_square_34(y_c, x_c):
				if (x_, y_, z_c) in dots_dict:
					for y__, z__ in boundary_square_34(y_c, z_c):
						if (x_c, y__, z__) in dots_dict:
							return False
		elif direction == 'z':
			for z_, x_ in boundary_square_34(z_c, x_c):
				if (x_, y_c, z_) in dots_dict:
					for x__, y__ in boundary_square_34(z_c, y_c):
						if (x__, y__, z_c) in dots_dict:
							return False
		
		return True
	
	new_dots = []
	dots_problem = []
	dots_to_remove = []
	for dot in dots_dict:
		# z
		count, dots = neighbours_InPlaneTwoDots(*dot, dots_dict, direction='z')
		if count == 2:
			if planeEmptyCheck_helper_twoDots(*dot, dots_dict, direction='z'):
				new_dots.append(tuple(np.sum(dots, axis=0) / 2))
				for dot_ in dots:
					dots_to_remove.append(dot_)
		# y
		count, dots = neighbours_InPlaneTwoDots(*dot, dots_dict, direction='y')
		if count == 2:
			if planeEmptyCheck_helper_twoDots(*dot, dots_dict, direction='y'):
				new_dots.append(tuple(np.sum(dots, axis=0) / 2))
				for dot_ in dots:
					dots_to_remove.append(dot_)
		# x
		count, dots = neighbours_InPlaneTwoDots(*dot, dots_dict, direction='x')
		if count == 2:
			if planeEmptyCheck_helper_twoDots(*dot, dots_dict, direction='x'):
				new_dots.append(tuple(np.sum(dots, axis=0) / 2))
				for dot_ in dots:
					dots_to_remove.append(dot_)
	for dot in set(dots_to_remove):
		dots_dict.pop(dot)
	return np.array(new_dots), np.array(dots_problem)


def filter_PlaneTwoClusters_Vertical(dots_dict):
	pass


def globalFilterDots(dots_dict, single_dot=False, print_=False):
	"""
	Applying all the filters to the dictionary of dots
	:param dots_dict: dictionary with all the dots
	:return: [[dots from 1st filter], [dots from 2nd filter], ... [(1,2,3),(2,3,4), ...], ...]
	"""
	import copy
	dots_dict_copy = copy.deepcopy(dots_dict)
	dots_final = []
	if print_:
		print('raw: ', len(dots_dict_copy))
	
	dots_final.append(filter_ZeroNeighbours(dots_dict_copy)[0])
	if print_:
		print('0. zero neighbour: ', len(dots_dict_copy))
	if not single_dot:
		dots_final.append(filter_OneNeighbours(dots_dict_copy)[0])
		if print_:
			print('1. one neighbour: ', len(dots_dict_copy))
		dots_final.append(filter_TwoNeighbours(dots_dict_copy)[0])
		if print_:
			print('2. two neighbours: ', len(dots_dict_copy))
		dots_final.append(filter_ThreeNeighbours(dots_dict_copy)[0])
		if print_:
			print('3. three neighbours: ', len(dots_dict_copy))
		dots_final.append(filter_PlaneThreeClusters(dots_dict_copy)[0])
		if print_:
			print('4. plane 3 dots: ', len(dots_dict_copy))
		dots_final.append(filter_PlaneTwoClusters(dots_dict_copy)[0])
		if print_:
			print('5. plane 2 dots (FINAL LENGTH): ', len(dots_dict_copy))
	return dots_final, dots_dict_copy


def filtered_dots(dots_dict, single_dot=False):
	"""
	It's a wrapper for globalFilterDots()
	This function places all the filtered dots into 1 array. It checks, if the arrays are empty as well.
	:param dots_dict: dictionary with all the dots
	"""
	dots_final, dots_left = globalFilterDots(dots_dict, single_dot=single_dot)
	dots_final_combined = []
	for dots_arrays in dots_final:
		if len(dots_arrays) != 0:
			for dot in dots_arrays:
				dots_final_combined.append(dot)
	for dot in dots_left:
		dots_final_combined.append(dot)
	dots_final_combined = np.array(dots_final_combined)
	return dots_final_combined


if __name__ == '__main__':
	"just a visualization of a trefoil knot to make sure you have everything working correctly"
	buildSaveTrefoil()
	dots, dots_dict = loadDots()
	dots_final, dots_left = globalFilterDots(dots_dict)
	dots_final_combined = filtered_dots(dots_dict)
	
	fig = plotDots(dots_final_combined, dots, color='blue', show=False, size=20)
	
	fig.show()
